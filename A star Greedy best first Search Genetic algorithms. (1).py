#!/usr/bin/env python
# coding: utf-8

# # 22k-4005 Mujtaba Saqib

# Task#1:
# Given a target string, the goal is to produce target string starting from a random string of
# the same length. In the following implementation, following analogies are made:  Characters A-Z, a-z, 0-9 and other special symbols are considered as genes  A string generated by these characters is considered as chromosome/solution/Individual  Population size= 70  Target string to be generated: TARGET = "Artificial Intelligence Lab"  Fitness score is the number of characters which differ from characters in target string at a
# particular index. So, individual having lower fitness value is given more preference.

# In[70]:


import random

POPULATION_SIZE = 70

GENES = "abcefgilnrtABCEGILNOPR "

TARGET = "Artificial Intelligence Lab"

def random_num(start, end):
    range_ = (end-start) + 1
    random_int = start + (random.randint(0, range_ - 1))
    return random_int

def mutated_genes():
    len_ = len(GENES)
    r = random_num(0,len_-1)
    return GENES[r]

def create_gnome():
    len_ = len(TARGET)
    gnome = ""
    for _ in range(len_):
        gnome += mutated_genes()
    return gnome

class Individual:
    def __init__(self, chromosome):
        self.chromosome = chromosome
        self.fitness = self.cal_fitness()

    def mate(self, par2):
        child_chromosome = ""
        len_ = len(self.chromosome)
        for i in range(len_):
            p = random_num(0, 100) / 100
            if p < 0.45:
                child_chromosome += self.chromosome[i]
            elif p < 0.90:
                child_chromosome += par2.chromosome[i]
            else:
                child_chromosome += mutated_genes()
        return Individual(child_chromosome)

    def cal_fitness(self):
        len_ = len(TARGET)
        fitness = 0
        for i in range(len_):
            if self.chromosome[i] != TARGET[i]:
                fitness += 1
        return fitness

def main():
    random.seed()

    generation = 0
    population = []
    found = False

    for _ in range(POPULATION_SIZE):
        gnome = create_gnome()
        population.append(Individual(gnome))

    while not found:
        population.sort(key=lambda x: x.fitness)

        if population[0].fitness <= 0:
            found = True
            break

        new_generation = []

        s = (10*POPULATION_SIZE)//100
        new_generation.extend(population[:s])

        s = (90*POPULATION_SIZE)//100
        for _ in range(s):
            len_ = len(population)
            r = random_num(0, len(population)-1)
            parent1 = population[r]
            r = random_num(0, len(population)-1)
            parent2 = population[r]
            offspring = parent1.mate(parent2)
            new_generation.append(offspring)

        population = new_generation
        print(f"generation {generation}\tstring {population[0].chromosome}\tfitness {population[0].fitness}")
        generation += 1

    print(f"generation {generation}\tstring {population[0].chromosome}\tfitness {population[0].fitness}")

main()


# Implement genetic algorithm to the Traveling Salesman Problem.
# We have a set of four cities A, B, C, and D. The distances between the cities are also
# given to us. Here (4-1)! That is 3! Route can be generated. The tour with A B C D A will
# be
# the optimal route for given problem.
# Initial Population (set of solutions) = 6
# Fitness (Quality of solution) = each solution is generally
# represented as a string of binary numbers, known as a
# chromosome. The most common fitness function for TSP is the
# length of the route. However, the 'shorter' the route is - the better.
# Crossover point, exchange data after ‘1’ instances of the list.
# Mutation point perform between 2nd and 4th item.
# The pseudo code for genetic algorithm for implementing the Traveling salesman problem:
# GeneticAlgorithm ( )
# {
# Initialize population of routes of cities randomly with a function Random ( )
# Evaluate the fitness of each individual route using function Fitness ( )
# While the fitness criteria is not satisfied do
# {
# Selection of two routes for reproduction using select function
# (Select (parent_route1, parent_route2))
# Perform crossover on the selected parent routes with crossover function
# (child_route = Crossover (parent_route1, parent_route2))
# Perform mutation on the newly generated child routes with mutation function
# (Mutation (child_route) )
# Evaluate the fitness of child_route and replace the parent population with child_route
# 
# } }

# In[65]:


import random

def create_route(cities):
    return random.sample(cities, len(cities))

def calculate_distance(route, distance_matrix):
    distance = 0
    for i in range(len(route)):
        distance += distance_matrix[route[i-1]][route[i]]
    return distance

def select_parents(population, fitness):
    return random.sample(population, 2)

def crossover(parent1, parent2):
    cp1, cp2 = sorted(random.sample(range(len(parent1)), 2))
    child = [None]*len(parent1)
    child[cp1:cp2] = parent1[cp1:cp2]
    child_pos = cp2
    for city in parent2:
        if city not in child:
            if child_pos >= len(parent1):
                child_pos = 0
            child[child_pos] = city
            child_pos += 1
    return child


def mutate(route):
    
    if len(route) > 3: 
        mutation_points = sorted(random.sample(range(1, len(route) - 1), 2)) 
    else:
        mutation_points = [1, 2] if len(route) == 4 else [1, 1]
    
    route[mutation_points[0]], route[mutation_points[1]] = route[mutation_points[1]], route[mutation_points[0]]
    return route

def is_fitness_criteria_met(fitness_scores, generation, max_generations, threshold_distance):
    return min(fitness_scores) <= threshold_distance or generation >= max_generations

def genetic_algorithm(cities, distance_matrix, threshold_distance=10, max_generations=100):
    population = [create_route(cities) for _ in range(6)]
    fitness_scores = [calculate_distance(route, distance_matrix) for route in population]
    
    generation = 0
    while not is_fitness_criteria_met(fitness_scores, generation, max_generations, threshold_distance):
        parent1, parent2 = select_parents(population, fitness_scores)
        child = crossover(parent1, parent2)
        child = mutate(child)
        child_fitness = calculate_distance(child, distance_matrix)   
        worst_route_index = fitness_scores.index(max(fitness_scores))
        if child_fitness < fitness_scores[worst_route_index]:
            population[worst_route_index] = child
            fitness_scores[worst_route_index] = child_fitness
        
        generation += 1

    best_index = fitness_scores.index(min(fitness_scores))
    return population[best_index], fitness_scores[best_index], generation

cities = [0, 1, 2, 3] 
distance_matrix = [
    [0, 3, 6, 7],  
    [3, 0, 2, 4],  
    [6, 2, 0, 4],  
    [7, 4, 4, 0]
]

best_route, best_distance, generation = genetic_algorithm(cities, distance_matrix)
print(f"best route {best_route} with distance {best_distance} found in generation {generation}")


# Task#3:
# Implement the following tree using greedy algorithm having a destination node H.

# In[76]:


import random

def heuristic(node):
    h_values = {'A':12,'B':4,'C':7,'D':3,'E':8,'F':2,'G':13,'H':0,'I':9,'S':10}
    return h_values[node.name()]

class node:
    def __init__(self, name: str, coords: tuple):
        self._name = name
        self._x = coords[0]
        self._y = coords[1]

    def name(self):
        return self._name

    def x(self):
        return self._x

    def y(self):
        return self._y

    def toString(self):
        return str(self.name()) 

    def __str__(self):
        return self.toString()

    def __repr__(self):
        return self.toString()

class edge:
    def __init__(self, start: Node, end: Node, cost: int):
        self._start = start
        self._end   = end
        self._cost  = cost

    def start(self):
        return self._start

    def end(self):
        return self._end

    def cost(self):
        return self._cost

    def toString(self):
        return str(self.start()) + "->" + str(self.end()) + "(" + str(self.cost()) + ")"

    def __str__(self):
        return self.toString()

    def __repr__(self):
        return self.toString()

class graph:
    def __init__(self, data):
        self._valueToNode = {v: Node(v, data[v]['coords']) for v in data}
        self._valueToEdge = {}
        for start_v, start_data in data.items():
            for end_v, end_cost in start_data["neighbors"].items():
                self._valueToEdge[(start_v, end_v)] = Edge(self._valueToNode[start_v], self._valueToNode[end_v], end_cost)
        self._nodes= list(self._valueToNode.values())
        self._edges= list(self._valueToEdge.values())

    def getNode(self,v):
        return self._valueToNode[v]

    def getEdge(self,start_v,end_v):   
        return self._valueToEdge[(start_v, end_v)]

    def neighbors(self,node):
        return [self.getEdge(node.name(), neighbor) for neighbor in graph_data[node.name()]['neighbors']]

    def cost(self,from_node,to_edge):
        return to_edge.cost()

    def toString(self):
        return "graph "+" " + "nodes " + str(self._nodes) + "\n" + " edges " + str(self._edges)

    def __str__(self):
        return self.toString()

    def __repr__(self):
        return self.toString()

class queue:
    def __init__(self,data=[]):
        self._elements = list(data)

    def empty(self):
        return len(self._elements) == 0

    def get(self):
        return self._elements.pop(0)

    def put(self, v):
        self._elements.insert(0, v)

    def toString(self):
        return "queue " + str(self._elements)

    def __str__(self):
        return self.toString()

    def __repr__(self):
        return self.toString()

class priorityqueue(Queue):
    def __init__(self, data=[]):
        super().__init__(data)
        self.reorder()

    def put(self,v):
        self._elements.append(v)
        self.reorder()

    def reorder(self):
        self._elements.sort(key=lambda v: v[1])

    def toString(self):
        return "priorityqueue " + str(self._elements)

def getPath(start,end,came_from):
    current = end 
    path = []
    while current != start: 
        path.append(current)
        if current not in came_from:
            return None
        current = came_from[current]
    path.append(start)
    path.reverse() 
    return path

def greedybestfirstsearch(graph, start, end):
    frontier = priorityqueue([(start, heuristic(start))])
    came_from = {start: None}
    cost_so_far = {start: 0}

    while not frontier.empty():
        current,_ = frontier.get()

        if current == end:
            break

        for next_edge in graph.neighbors(current):
            next_node = next_edge.end()
            new_cost = cost_so_far[current] + next_edge.cost()
            if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:
                cost_so_far[next_node] = new_cost
                priority = heuristic(next_node)
                frontier.put((next_node, priority))
                came_from[next_node] = current

    return getPath(start, end, came_from)

graph_data = {
    'S': {'coords':(0,0),'neighbors':{'A':3,'B':2}},
    'A': {'coords':(0,0),'neighbors':{'C':4,'D':1}},
    'B': {'coords':(0,0),'neighbors':{'D':1,'E':5,'F':3}},
    'C': {'coords':(0,0),'neighbors':{}},
    'D': {'coords':(0,0),'neighbors':{'H':5}},
    'E': {'coords':(0,0),'neighbors':{'H':8}},
    'F': {'coords':(0,0),'neighbors':{'G':3}},
    'G': {'coords':(0,0),'neighbors':{}},
    'H': {'coords':(0,0),'neighbors':{}},
    'I': {'coords':(0,0),'neighbors':{'G':3,'H':1}},
}

graph = graph(graph_data)

start_node = graph.getNode('S')
end_node = graph.getNode('H')

path = greedybestfirstsearch(graph,start_node,end_node)

if path is not None:
    print("path found ", path)
else:
    print("no path found")


# Task#4:
# Implement the following graph using A* search algorithm starting from Node S to Node D.

# In[73]:


from collections import deque

class Graph:
    def __init__(self,adjacency_list):
        self.adjacency_list = adjacency_list

    def get_neighbors(self,v):
        return self.adjacency_list[v]

    def h(self, n):
        H = {
            'S': 5,
            'A': 3,
            'B': 4,
            'C': 2,
            'D': 6,
            'G': 0  
        }
        return H.get(n, float('inf'))

    def a_star_algorithm(self, start_node, stop_node):
        open_list = set([start_node])
        closed_list = set([])
        g = {}
        
        g[start_node] = 0
        parents = {}
        parents[start_node] = start_node

        while len(open_list)>0:
            n = None
            for v in open_list:
                if n is None or g[v] + self.h(v) < g[n] + self.h(n):
                    n = v

            if n is None:
                print('Path does not exist!')
                return None

            if n == stop_node:
                reconst_path = []

                while parents[n] != n:
                    reconst_path.append(n)
                    n = parents[n]

                reconst_path.append(start_node)
                reconst_path.reverse()

                print('Path found: {}'.format(reconst_path))
                return reconst_path

            for (m, weight) in self.get_neighbors(n):
                if m not in open_list and m not in closed_list:
                    open_list.add(m)
                    parents[m] = n
                    g[m] = g[n] + weight
                else:
                    if g[m] > g[n] + weight:
                        g[m] = g[n] + weight
                        parents[m] = n

                        if m in closed_list:
                            closed_list.remove(m)
                            open_list.add(m)

            open_list.remove(n)
            closed_list.add(n)

        print('Path does not exist!')
        return None

adjacency_list = {
    'S': [('A',1),('C',10)],
    'A': [('B',1)],
    'B': [('D',5)],
    'C': [('D',3)],
    'D': [('G',4)]  
}

graph1 = Graph(adjacency_list)
graph1.a_star_algorithm('S','D')  


# Task#5:
# Solve the below maze using Greedy Best First and A* Best First search algorithm.

# In[74]:


import numpy as np

class Graph:
    def __init__(self,weights,rows,cols):
        self.weights = weights
        self.rows = rows
        self.cols = cols
        self.edges = self._create_edges()

    def _create_edges(self):
        edges = {}
        for i in range(self.rows):
            for j in range(self.cols):
                edges[(i,j)] = self._get_neighbors(i,j)
        return edges

    def _get_neighbors(self,row,col):
        neighbors = []
        if row > 0:
            neighbors.append(((row-1,col),self.weights[row-1][col]))
        if row < self.rows-1:
            neighbors.append(((row+1,col),self.weights[row+1][col]))
        if col > 0:
            neighbors.append(((row,col-1),self.weights[row][col-1]))
        if col < self.cols-1:
            neighbors.append(((row,col+1),self.weights[row][col+1]))
        return neighbors

    def neighbors(self,node):
        return self.edges[node]

def heuristic(node, goal):
    return abs(node[0]-goal[0])+abs(node[1]-goal[1])

def greedy_best_first_search(graph,start,end):
    frontier = PriorityQueue()
    frontier.put((0, start))
    came_from = {start: None}
    cost_so_far = {start: 0}

    while not frontier.empty():
        _,current = frontier.get()

        if current == end:
            break

        for next_node, _ in graph.neighbors(current):
            if next_node not in came_from:
                priority = heuristic(next_node, end)
                frontier.put((priority, next_node))
                came_from[next_node] = current

    return reconstruct_path(came_from,start,end)

def reconstruct_path(came_from,start,end):
    current = end
    path = [current]
    while current != start:
        current = came_from[current]
        path.append(current)
    path.reverse()
    return path

def a_star_search(graph, start, end):
    frontier = PriorityQueue()
    frontier.put((0, start))
    came_from = {start: None}
    cost_so_far = {start: 0}

    while not frontier.empty():
        _, current = frontier.get()

        if current == end:
            break

        for next_node, cost in graph.neighbors(current):
            new_cost = cost_so_far[current] + cost
            if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:
                cost_so_far[next_node] = new_cost
                priority = new_cost + heuristic(next_node, end)
                frontier.put((priority, next_node))
                came_from[next_node] = current

    return reconstruct_path(came_from, start, end)

weights = np.array([
    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0],
    [11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    [12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2],
    [13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3],
    [14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4],
    [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5],
    [16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6]
])

maze_graph = Graph(weights,rows=7,cols=11) 

start_point = (6,0)
end_point = (0,10)   

greedy_path = greedy_best_first_search(maze_graph, start_point, end_point)
a_star_path = a_star_search(maze_graph, start_point, end_point)

print("greedy best first search path ", greedy_path)
print()
print("a* search fath ", a_star_path)


# Task#6:
# Write a program to solve the 8-puzzle problem using Heuristics (h(n)) for A*

# In[77]:


from queue import PriorityQueue

goal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)

moves = {
    0: (1,3),
    1: (0,2,4),
    2: (1,5),
    3: (0,4,6),
    4: (1,3,5,7),
    5: (2,4,8),
    6: (3,7),
    7: (4,6,8),
    8: (5,7)
}

def heuristic(state):
    distance = 0
    for i in range(3):
        for j in range(3):
            value = state[i*3+j]
            if value != 0:
                target_row = (value-1)//3
                target_col = (value-1)%3
                distance += abs(i-target_row)+abs(j-target_col)
    return distance

def solve_puzzle(start_state):
    frontier = PriorityQueue()
    frontier.put((0, start_state))
    came_from = {}
    cost_so_far = {start_state: 0}

    while not frontier.empty():
        current_cost, current_state = frontier.get()

        if current_state == goal_state:
            break

        for next_move in moves[current_state.index(0)]:
            new_state = list(current_state)
            new_state[current_state.index(0)], new_state[next_move] = new_state[next_move], new_state[current_state.index(0)]
            new_state = tuple(new_state)
            new_cost = cost_so_far[current_state] + 1

            if new_state not in cost_so_far or new_cost < cost_so_far[new_state]:
                cost_so_far[new_state] = new_cost
                priority = new_cost + heuristic(new_state)
                frontier.put((priority, new_state))
                came_from[new_state] = current_state

    path = []
    current_state = goal_state
    while current_state!= start_state:
        path.append(current_state)
        current_state = came_from[current_state]
    path.append(start_state)
    path.reverse()
    return path

start_state_tuple = (1,2,3,0,4,6,7,5,8)
solution = solve_puzzle(start_state_tuple)
print("solution ")
for item in solution:
    state = item[0]
    g_n = item[1]
    h_n = item[2]
    f_n = item[3]
    print(f"g(n) {g_n}, h(n) {h_n}, f(n) {f_n}")
    
print("\n")    
for state in solution:
    print(state[0:3])
    print(state[3:6])
    print(state[6:])
    print()


# In[ ]:





# In[ ]:




